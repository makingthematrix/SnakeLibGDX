1. The draw method in Draw.scala draws a board made of tiles. The board is then displayed on the screen (the framework we work with is LibGDX). Right now every tile is white. Change the code so that each tile has a thin black border so the viewer can easily recognize one tile from the next.
2. In the implementation of drawTexture, wrap the Texture into Sprite and set its size to the size of the square.
3. Create subfolders for unit tests for the project. The unit tests will be written in Scala and use mUnit as its test framework - add mUnit to the depndencies. Generate unit tests for the methods in Models.scala. Put them in a file called ModelsSuite.scala. Run them.
4. Create the Snake companion object and an apply method that takes a list of tuples (x: Int, y: Int). The list becomes the snake body but only if they are continuous, i.e. if the sum of the differences between xs and ys of two consecutive tuples is exactly 1. Add new unit tests to ModelsSuite to test this logic and update old unit tests if necessary.
5. Create new methods in the Snake class:
   1. changeDirection, that takes a SnakeDir and returns a new Snake instance with the updated snakeDir
   2. crawl, that removes the last tuple from the snake's body and adds a new one at the head. The new head is the old head updated by the (x, y) coordinates of snakeDir.
6. Add unit tests:
   1. one where you ensure that the size of a snake after the crawl is the same as the size before the crawl.
   2. one where you se the direction of the crawl to Right and after the crawl you check if the list of tuples in the snake's body are right - i.e. there should be a new head, there should no original tail, and the other tuples should be intact.
      Create a method in Snake to access its body.
7. Rewrite the Snake.crawl method. The new version should use Main.BOARD_SIZE to ensure that the snake will never crawl outside of the board. If the computations make the new head have x or y equal -1 or equal Main.BOARD_SIZE, instead it should wrap over the board: the x or y that is -1 becomes Main.BOARD_SIZE-1, and the x or y that is Main.BOARD_SIZE becomes 0. Update unit tests and write new ones.
8. Write the update method for the board. The update should call `_snake.crawl` and replace the original _snake with the new one. Then, it should check if there is a coin at the place of the snake's head. If yes, the coin should be removed from the list.
9. Rewrite the Main class so that the game is run in an infinite game loop. Inside the game loop, the program calls Draw.render(board), checks if the user hits any key, waits 1s for that to happen, and if it doesn't, then the program calls board.update, and goes back to the beginning. If the user hit any key, stop the game.
10. Call from here a new method that will check what key was hit. If it was one of the arrow keys: Left, Right, Up, or Down, update the snake on the board, changing its snakeDir respectively to SnakeDir.Left, Right, Up, and Down. Create methods that will allow you to make such an update.
11. Forbid to change direction backwards (Up to Down, Left to Right, and vice versa). Change the result type of the method to Boolean and return true if changing the direction succeeded, false otherwise.
12. Create a new immutable field `hasCoin: Boolean` in the Snake class, and set it by default to false. In the Board.update method, if the snake's head is on the same position as a coin, update the snake in the board and change `setCoin` to true. In the Snake.crawl method, check if `hasCoin` is true. If it is, don't remove the last tuple from the snake's body, but instead change `hasCoin` back to false. Create methods for setting and geeting `hasCoin` as well as updating the snake in the Board instance. Write unit tests.
13. Add a method to the Board class to get the list of positions of all empty tiles - ones without the snake or coins. Make a method in the Main class that will take that list and randomly choose one of them. Create a field `newCoinInterval: Float` that will describe how often a new coin should appear on the board. By default it should be 10s. Add to the game loop the logic that updates the board by adding a new coin on one of the empty tiles every newCoinInterval, but only if `board.coinsNumber` is less than MAX_COINS. Write new unit tests.
14. Write a method that will check if the head of the snake is not on the same place as one of its other body tuples. Use it in the main game loop. If yes, the game should end.
15. If there is a self-collision, display a popup with the text "Score: " followed by the length of the snake at the moment of self-collision. When the user closes the popup, end the program.
16. Rewrite the Main.handleKeyPress logic suct that only two keys are being used: LEFT and RIGHT. Get the current snakeDir and if the user hits the arrow RIGHT key, then update snake direton clockwise: from Up to Right, Right to Down, Down to Left, and Left to Up. If the user hits the arrow LEFT key, then update snake direction counter-clockwise.
17. Instead of checking Gdx.input.isKeyPressed in handleKeyPress, register an InputProcessor in Gdx.input. The new InputProcessor should handle the keyUp method, check its keycode, and perform updates on the snake direction based on that.
